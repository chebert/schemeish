;;;; package.lisp

(defpackage #:schemeish
  (:use #:cl)
  (:shadow #:map
	   #:let
	   #:sort
	   #:stream)
  (:export
   #:for-macros
   #:map
   #:let
   #:install-syntax!
   #:group
   #:Î»
   #:append*
   #:empty?
   #:define
   #:make-bundle-predicate
   #:*get-bundle-list*
   #:make-keyword
   #:bundle
   #:bundle-permissions
   #:bundle-list
   #:filter
   #:pair?
   #:null?
   #:list?
   #:list-ref
   #:list-tail
   #:foldr
   #:foldl
   #:positive?
   #:eq?
   #:equal?
   #:andmap
   #:ormap
   #:for-each
   #:remq
   #:remq*
   #:remove*
   #:sort
   #:memf
   #:findf
   #:list-update
   #:symbol->string
   #:take
   #:drop
   #:split-at
   #:even?
   #:dropf
   #:takef
   #:splitf-at
   #:flatten
   #:filter-map
   #:partition
   #:range
   #:append-map
   #:filter-not
   #:procedure?
   #:compose
   #:swap-args
   #:rcurry
   #:lcurry
   #:memo-proc
   #:delay
   #:force
   #:stream-cons
   #:stream-car
   #:stream-cdr
   #:stream-for-each
   #:*the-empty-stream*
   #:stream-empty?
   #:stream-first
   #:stream-rest
   #:list->stream
   #:stream?
   #:stream-map
   #:stream-fold
   #:stream-filter
   #:alist-set
   #:alist-remove
   #:alist-ref
   #:alist-update
   #:alist-map
   #:alist-keys
   #:alist
   #:alist-set*
   #:alist-has-key?
   #:alist-values
   #:negative?
   #:stream
   #:stream-length
   #:stream-drop
   #:stream-take
   #:stream-ref
   #:stream-append
   #:stream-flatten
   #:stream-flatmap
   #:stream-range
   #:stream-collect
   #:disjoin*
   #:conjoin*
   #:conjoin
   #:const))
